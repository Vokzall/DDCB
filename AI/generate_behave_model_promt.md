# Задача: Создание поведенческой модели с учетом задержек из SDF

## Входные данные

У вас есть три файла:

1. **lib_cells.v** - библиотека примитивов с их функциональным описанием
2. **cascade_delays_netlist.v** - синтезированный нетлист модуля
3. **cascade_delays.sdf** - файл с временными задержками (Standard Delay Format)

## Задача

Создайте поведенческое (behavioral) описание модуля **cascade_delays_behavioral**, которое:

1. Имеет те же порты, что и модуль в нетлисте
2. Реализует ту же логику работы
3. **Точно воспроизводит все задержки из SDF файла**

## Требования к реализации

### 1. Временная шкала (timescale)
```verilog
`timescale 1ns / 1ps
```
- Единица времени: 1 наносекунда
- Точность: 1 пикосекунда
- Все задержки должны быть пересчитаны из пикосекунд в наносекунды (делением на 1000)

### 2. Анализ структуры

Перед написанием кода необходимо:

**a) Изучить нетлист:**
- Определить количество каскадов/стадий
- Понять топологию соединений между элементами
- Определить, как именно подключены входы примитивов (I0, I1, S и т.д.)

**b) Изучить SDF файл:**
- Найти задержки для каждого экземпляра (INSTANCE)
- Обратить внимание на различные задержки для разных путей (IOPATH)
- Учесть условные задержки (COND)
- Обратить внимание, что задержки могут различаться для rising/falling фронтов

**c) Изучить библиотеку примитивов:**
- Понять функциональность каждого примитива
- Понять, как работает мультиплексор (какой вход выбирается при S=0 и S=1)

### 3. Моделирование задержек

**Для буферов:**
```verilog
// Если задержки для rise и fall разные:
always @(input_signal) begin
    if (input_signal == 1'b1)
        output_signal <= #rise_delay input_signal;
    else
        output_signal <= #fall_delay input_signal;
end

// Если задержки одинаковые:
always @(input_signal) begin
    output_signal <= #delay input_signal;
end
```

**Для мультиплексоров:**
```verilog
always @(input0 or input1 or select) begin
    if (select == 1'b0) begin
        // Путь I0 -> Z
        if (input0 == 1'b1)
            output <= #rise_delay_I0 input0;
        else
            output <= #fall_delay_I0 input0;
    end else begin
        // Путь I1 -> Z
        if (input1 == 1'b1)
            output <= #rise_delay_I1 input1;
        else
            output <= #fall_delay_I1 input1;
    end
end
```

### 4. Извлечение задержек из SDF

Для каждого INSTANCE в SDF файле:

**Буфер (BUFV1_140P9T30R):**
```
(IOPATH I Z (::rise_delay) (::fall_delay))
```

**Мультиплексор (CLKMUX2V0_140P9T30R):**
```
(IOPATH I0 Z (::rise_delay) (::fall_delay))
(IOPATH I1 Z (::rise_delay) (::fall_delay))
```

### 5. Важные замечания

**a) Порядок подключения:**
- Внимательно смотрите на порядок подключения сигналов к I0 и I1 в нетлисте
- Например: `.I0 (in), .I1 (\delay_in[0] )` означает, что I0 подключен к прямому сигналу
- Не путайте номера портов с их функцией!

**b) Различие задержек:**
- Задержки могут быть разными для разных каскадов
- Последний каскад часто имеет отличающиеся задержки
- Rising и falling задержки могут отличаться

**c) Внутренние сигналы:**
- Создайте регистры для всех промежуточных сигналов (delay_in, delay_out)
- Размерность массивов должна соответствовать количеству каскадов

**d) Комментарии:**
- Добавьте комментарии с указанием значений задержек для каждого каскада
- Укажите, какой путь реализуется (прямой/задержанный)

## Пример структуры модуля

```verilog
`timescale 1ns / 1ps

module cascade_delays_behavioral(
    input wire in,
    input wire [N-1:0] select,
    output reg out
);

    // Внутренние сигналы
    reg [N-1:0] delay_in;
    reg [N-2:0] delay_out;
    
    // Stage 0
    always @(in) begin
        // Буфер с задержками из SDF
        ...
    end
    
    always @(in or delay_in[0] or select[0]) begin
        // Мультиплексор с задержками из SDF
        ...
    end
    
    // Stage 1, 2, ... N-1
    ...
    
endmodule
```

## Проверка правильности

После написания модуля проверьте:

1. ✅ Количество каскадов соответствует нетлисту
2. ✅ Все задержки из SDF учтены
3. ✅ Подключения I0/I1 соответствуют нетлисту
4. ✅ Логика работы мультиплексоров корректна
5. ✅ Все задержки пересчитаны в наносекунды
6. ✅ Rising/falling задержки применяются правильно
7. ✅ Имена портов модуля совпадают с нетлистом

## Формат вывода

Предоставьте готовый Verilog файл с поведенческой моделью, который можно использовать для симуляции с точными временными характеристиками.